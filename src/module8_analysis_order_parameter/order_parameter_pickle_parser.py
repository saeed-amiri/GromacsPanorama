"""
This module processes data from the order_parameter_pickle file, which
is generated by the trajectory_to_order_parameter.py script. It focuses
on splitting and organizing data based on residue types for further
analysis.

File Contents:
    The order_parameter_pickle file contains the tensor of the order
    parameter for each residue in the x, y, and z axes. These parameters
    are computed specifically for water (SOL), oil (ODA), and decane
    (D10), with other residues set to zero.

Array Structure:
    The data within the pickle file is structured as follows:

    Rows: The total number of rows equals the number of frames in the
    simulation plus two additional rows. These additional rows are
    used for:
        Identifying the type of each residue (-1 row).
        Storing the original index of the residues as found in the
        trajectory file (-2 row).

    Columns: The columns are organized to represent various data points:
        The first column (0 index) represents the time frame of the
        simulation.
        The next three columns (1 to 3 index) store the center of mass
        of the nanoparticle.
        Subsequent columns are dedicated to the xyz coordinates of the
        residues in solution (excluding those in the nanoparticle).

Data Layout:
    The layout of the columns is as follows:
    Time Frame | NP (x, y, z) | Residues (Sx1, Sy1, Sz1, Sx2, Sy2, Sz2,
    ...)
    S stands for order parameter

Alignment with com_pickle:
    The file is structured to align with the com_pickle file, which
    contains the center of mass of each particle in the system. This
    alignment facilitates the integration and comparative analysis of
    order parameters with spatial data.
"""

import typing
from dataclasses import dataclass

import pickle
import numpy as np

from common import logger, my_tools
from common import static_info as stinfo
from common.colors_text import TextColor as bcolors


@dataclass
class FileConfig:
    """set the file names"""
    op_pickle: str = 'order_parameter_pickle'


@dataclass
class AllConfig(FileConfig):
    """set all the configuratiions"""


class GetOorderParameter:
    """
    Processing and splitting the data based on the residues type
    """

    info_msg: str = 'Message from GetOorderParameter:\n'
    configs: AllConfig
    split_arr_dict: dict[str, np.ndarray]  # Array of each residue

    def __init__(self,
                 log: logger.logging.Logger,
                 configs: AllConfig = AllConfig()
                 ) -> None:
        self.configs = configs
        self.split_arr_dict = self._initiate_data(log)
        self.nr_dict: dict[str, int] = self.get_numbers(self.split_arr_dict)
        self._write_msg(log)

    def _initiate_data(self,
                       log: logger.logging.Logger
                       ) -> dict[str, np.ndarray]:
        """load the main data"""
        my_tools.check_file_exist(self.configs.op_pickle, log)
        orderp_arr: np.ndarray = self.load_pickle(self.configs.op_pickle)
        split_arr_dict: dict[str, np.ndarray] = \
            self.split_data(orderp_arr[:, 4:])
        return split_arr_dict

    def split_data(self,
                   data: np.ndarray  # Loaded data without first 4 columns
                   ) -> dict[str, np.ndarray]:
        """
        Split data based on the type of the residues.

        Args:
            data (np.ndarray): The data to be split, excluding the
            first 4 columns.

        Returns:
            dict[str, np.ndarray]: A dictionary of residue names and
            their associated arrays.
        """
        # Get the last row of the array
        last_row: np.ndarray = data[-1]
        last_row_indices: np.ndarray = last_row.astype(int)
        unique_indices: np.ndarray = np.unique(last_row_indices)

        # Create an empty dictionary to store the split arrays
        result_dict: dict[int, list] = {index: [] for index in unique_indices}
        # Iterate through each column and split based on the indices
        for col_idx, column in enumerate(data.T):
            result_dict[last_row_indices[col_idx]].append(column)

        # Convert the dictionary values back to numpy arrays
        result: list[np.ndarray] = \
            [np.array(arr_list).T for arr_list in result_dict.values()]

        array_dict: dict[str, np.ndarray] = {}
        # !!! Very risky kinda way to do the follwing:
        for i, arr in enumerate(result, start=1):
            residue_name = self.find_key_by_value(stinfo.reidues_id, i)
            array_dict[residue_name] = arr
        return array_dict

    @staticmethod
    def find_key_by_value(dictionary: dict[typing.Any, typing.Any],
                          target_value: typing.Any
                          ) -> typing.Any:
        """
        Find the key in the dictionary based on the target value.

        Args:
            dictionary (dict): The dictionary to search.
            target_value: The value to search for.

        Returns:
            str or None: The key associated with the target value, or
            None if not found.
        """
        return next((key for key, value in dictionary.items() if
                     value == target_value), None)

    @staticmethod
    def get_numbers(data: dict[str, np.ndarray]  # Splitted np.arrays
                    ) -> dict[str, int]:
        """
        Get the number of time frames and the number of residues for
        each type.

        Args:
            data (dict[str, np.ndarray]): The split data dictionary.

        Returns:
            dict[str, int]: A dictionary containing the number of time
            frames and the number of residues for each type.
        """
        nr_dict: dict[str, int] = {}
        nr_dict['nr_frames'] = np.shape(data['SOL'])[0] - 2
        for item, arr in data.items():
            nr_dict[item] = np.shape(arr)[1] // 3
        return nr_dict

    @staticmethod
    def load_pickle(fname: str) -> np.ndarray:
        """loading the input file"""
        with open(fname, 'rb') as f_rb:
            orderp_arr = pickle.load(f_rb)
        return orderp_arr

    def _write_msg(self,
                   log: logger.logging.Logger  # To log
                   ) -> None:
        """write and log messages"""
        print(f'{bcolors.OKCYAN}{GetOorderParameter.__name__}:\n'
              f'\t{self.info_msg}{bcolors.ENDC}')
        log.info(self.info_msg)


if __name__ == '__main__':
    GetOorderParameter(log=logger.setup_logger('order_parameter_prase.log'))
